// Code generated by counterfeiter. DO NOT EDIT.
package gardenfakes

import (
	"io"
	"sync"
	"time"

	"code.cloudfoundry.org/garden"
)

type FakeContainer struct {
	HandleStub        func() string
	handleMutex       sync.RWMutex
	handleArgsForCall []struct{}
	handleReturns     struct {
		result1 string
	}
	handleReturnsOnCall map[int]struct {
		result1 string
	}
	StopStub        func(kill bool) error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		kill bool
	}
	stopReturns struct {
		result1 error
	}
	stopReturnsOnCall map[int]struct {
		result1 error
	}
	InfoStub        func() (garden.ContainerInfo, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct{}
	infoReturns     struct {
		result1 garden.ContainerInfo
		result2 error
	}
	infoReturnsOnCall map[int]struct {
		result1 garden.ContainerInfo
		result2 error
	}
	StreamInStub        func(spec garden.StreamInSpec) error
	streamInMutex       sync.RWMutex
	streamInArgsForCall []struct {
		spec garden.StreamInSpec
	}
	streamInReturns struct {
		result1 error
	}
	streamInReturnsOnCall map[int]struct {
		result1 error
	}
	StreamOutStub        func(spec garden.StreamOutSpec) (io.ReadCloser, error)
	streamOutMutex       sync.RWMutex
	streamOutArgsForCall []struct {
		spec garden.StreamOutSpec
	}
	streamOutReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	streamOutReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	CurrentBandwidthLimitsStub        func() (garden.BandwidthLimits, error)
	currentBandwidthLimitsMutex       sync.RWMutex
	currentBandwidthLimitsArgsForCall []struct{}
	currentBandwidthLimitsReturns     struct {
		result1 garden.BandwidthLimits
		result2 error
	}
	currentBandwidthLimitsReturnsOnCall map[int]struct {
		result1 garden.BandwidthLimits
		result2 error
	}
	CurrentCPULimitsStub        func() (garden.CPULimits, error)
	currentCPULimitsMutex       sync.RWMutex
	currentCPULimitsArgsForCall []struct{}
	currentCPULimitsReturns     struct {
		result1 garden.CPULimits
		result2 error
	}
	currentCPULimitsReturnsOnCall map[int]struct {
		result1 garden.CPULimits
		result2 error
	}
	CurrentDiskLimitsStub        func() (garden.DiskLimits, error)
	currentDiskLimitsMutex       sync.RWMutex
	currentDiskLimitsArgsForCall []struct{}
	currentDiskLimitsReturns     struct {
		result1 garden.DiskLimits
		result2 error
	}
	currentDiskLimitsReturnsOnCall map[int]struct {
		result1 garden.DiskLimits
		result2 error
	}
	CurrentMemoryLimitsStub        func() (garden.MemoryLimits, error)
	currentMemoryLimitsMutex       sync.RWMutex
	currentMemoryLimitsArgsForCall []struct{}
	currentMemoryLimitsReturns     struct {
		result1 garden.MemoryLimits
		result2 error
	}
	currentMemoryLimitsReturnsOnCall map[int]struct {
		result1 garden.MemoryLimits
		result2 error
	}
	NetInStub        func(hostPort, containerPort uint32) (uint32, uint32, error)
	netInMutex       sync.RWMutex
	netInArgsForCall []struct {
		hostPort      uint32
		containerPort uint32
	}
	netInReturns struct {
		result1 uint32
		result2 uint32
		result3 error
	}
	netInReturnsOnCall map[int]struct {
		result1 uint32
		result2 uint32
		result3 error
	}
	NetOutStub        func(netOutRule garden.NetOutRule) error
	netOutMutex       sync.RWMutex
	netOutArgsForCall []struct {
		netOutRule garden.NetOutRule
	}
	netOutReturns struct {
		result1 error
	}
	netOutReturnsOnCall map[int]struct {
		result1 error
	}
	BulkNetOutStub        func(netOutRules []garden.NetOutRule) error
	bulkNetOutMutex       sync.RWMutex
	bulkNetOutArgsForCall []struct {
		netOutRules []garden.NetOutRule
	}
	bulkNetOutReturns struct {
		result1 error
	}
	bulkNetOutReturnsOnCall map[int]struct {
		result1 error
	}
	RunStub        func(garden.ProcessSpec, garden.ProcessIO) (garden.Process, error)
	runMutex       sync.RWMutex
	runArgsForCall []struct {
		arg1 garden.ProcessSpec
		arg2 garden.ProcessIO
	}
	runReturns struct {
		result1 garden.Process
		result2 error
	}
	runReturnsOnCall map[int]struct {
		result1 garden.Process
		result2 error
	}
	AttachStub        func(processID string, io garden.ProcessIO) (garden.Process, error)
	attachMutex       sync.RWMutex
	attachArgsForCall []struct {
		processID string
		io        garden.ProcessIO
	}
	attachReturns struct {
		result1 garden.Process
		result2 error
	}
	attachReturnsOnCall map[int]struct {
		result1 garden.Process
		result2 error
	}
	MetricsStub        func() (garden.Metrics, error)
	metricsMutex       sync.RWMutex
	metricsArgsForCall []struct{}
	metricsReturns     struct {
		result1 garden.Metrics
		result2 error
	}
	metricsReturnsOnCall map[int]struct {
		result1 garden.Metrics
		result2 error
	}
	SetGraceTimeStub        func(graceTime time.Duration) error
	setGraceTimeMutex       sync.RWMutex
	setGraceTimeArgsForCall []struct {
		graceTime time.Duration
	}
	setGraceTimeReturns struct {
		result1 error
	}
	setGraceTimeReturnsOnCall map[int]struct {
		result1 error
	}
	PropertiesStub        func() (garden.Properties, error)
	propertiesMutex       sync.RWMutex
	propertiesArgsForCall []struct{}
	propertiesReturns     struct {
		result1 garden.Properties
		result2 error
	}
	propertiesReturnsOnCall map[int]struct {
		result1 garden.Properties
		result2 error
	}
	PropertyStub        func(name string) (string, error)
	propertyMutex       sync.RWMutex
	propertyArgsForCall []struct {
		name string
	}
	propertyReturns struct {
		result1 string
		result2 error
	}
	propertyReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SetPropertyStub        func(name string, value string) error
	setPropertyMutex       sync.RWMutex
	setPropertyArgsForCall []struct {
		name  string
		value string
	}
	setPropertyReturns struct {
		result1 error
	}
	setPropertyReturnsOnCall map[int]struct {
		result1 error
	}
	RemovePropertyStub        func(name string) error
	removePropertyMutex       sync.RWMutex
	removePropertyArgsForCall []struct {
		name string
	}
	removePropertyReturns struct {
		result1 error
	}
	removePropertyReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContainer) Handle() string {
	fake.handleMutex.Lock()
	ret, specificReturn := fake.handleReturnsOnCall[len(fake.handleArgsForCall)]
	fake.handleArgsForCall = append(fake.handleArgsForCall, struct{}{})
	fake.recordInvocation("Handle", []interface{}{})
	fake.handleMutex.Unlock()
	if fake.HandleStub != nil {
		return fake.HandleStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.handleReturns.result1
}

func (fake *FakeContainer) HandleCallCount() int {
	fake.handleMutex.RLock()
	defer fake.handleMutex.RUnlock()
	return len(fake.handleArgsForCall)
}

func (fake *FakeContainer) HandleReturns(result1 string) {
	fake.HandleStub = nil
	fake.handleReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContainer) HandleReturnsOnCall(i int, result1 string) {
	fake.HandleStub = nil
	if fake.handleReturnsOnCall == nil {
		fake.handleReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.handleReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeContainer) Stop(kill bool) error {
	fake.stopMutex.Lock()
	ret, specificReturn := fake.stopReturnsOnCall[len(fake.stopArgsForCall)]
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		kill bool
	}{kill})
	fake.recordInvocation("Stop", []interface{}{kill})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub(kill)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stopReturns.result1
}

func (fake *FakeContainer) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeContainer) StopArgsForCall(i int) bool {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return fake.stopArgsForCall[i].kill
}

func (fake *FakeContainer) StopReturns(result1 error) {
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) StopReturnsOnCall(i int, result1 error) {
	fake.StopStub = nil
	if fake.stopReturnsOnCall == nil {
		fake.stopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Info() (garden.ContainerInfo, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct{}{})
	fake.recordInvocation("Info", []interface{}{})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.infoReturns.result1, fake.infoReturns.result2
}

func (fake *FakeContainer) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeContainer) InfoReturns(result1 garden.ContainerInfo, result2 error) {
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 garden.ContainerInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) InfoReturnsOnCall(i int, result1 garden.ContainerInfo, result2 error) {
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 garden.ContainerInfo
			result2 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 garden.ContainerInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) StreamIn(spec garden.StreamInSpec) error {
	fake.streamInMutex.Lock()
	ret, specificReturn := fake.streamInReturnsOnCall[len(fake.streamInArgsForCall)]
	fake.streamInArgsForCall = append(fake.streamInArgsForCall, struct {
		spec garden.StreamInSpec
	}{spec})
	fake.recordInvocation("StreamIn", []interface{}{spec})
	fake.streamInMutex.Unlock()
	if fake.StreamInStub != nil {
		return fake.StreamInStub(spec)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.streamInReturns.result1
}

func (fake *FakeContainer) StreamInCallCount() int {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	return len(fake.streamInArgsForCall)
}

func (fake *FakeContainer) StreamInArgsForCall(i int) garden.StreamInSpec {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	return fake.streamInArgsForCall[i].spec
}

func (fake *FakeContainer) StreamInReturns(result1 error) {
	fake.StreamInStub = nil
	fake.streamInReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) StreamInReturnsOnCall(i int, result1 error) {
	fake.StreamInStub = nil
	if fake.streamInReturnsOnCall == nil {
		fake.streamInReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamInReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) StreamOut(spec garden.StreamOutSpec) (io.ReadCloser, error) {
	fake.streamOutMutex.Lock()
	ret, specificReturn := fake.streamOutReturnsOnCall[len(fake.streamOutArgsForCall)]
	fake.streamOutArgsForCall = append(fake.streamOutArgsForCall, struct {
		spec garden.StreamOutSpec
	}{spec})
	fake.recordInvocation("StreamOut", []interface{}{spec})
	fake.streamOutMutex.Unlock()
	if fake.StreamOutStub != nil {
		return fake.StreamOutStub(spec)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.streamOutReturns.result1, fake.streamOutReturns.result2
}

func (fake *FakeContainer) StreamOutCallCount() int {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	return len(fake.streamOutArgsForCall)
}

func (fake *FakeContainer) StreamOutArgsForCall(i int) garden.StreamOutSpec {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	return fake.streamOutArgsForCall[i].spec
}

func (fake *FakeContainer) StreamOutReturns(result1 io.ReadCloser, result2 error) {
	fake.StreamOutStub = nil
	fake.streamOutReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) StreamOutReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.StreamOutStub = nil
	if fake.streamOutReturnsOnCall == nil {
		fake.streamOutReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.streamOutReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentBandwidthLimits() (garden.BandwidthLimits, error) {
	fake.currentBandwidthLimitsMutex.Lock()
	ret, specificReturn := fake.currentBandwidthLimitsReturnsOnCall[len(fake.currentBandwidthLimitsArgsForCall)]
	fake.currentBandwidthLimitsArgsForCall = append(fake.currentBandwidthLimitsArgsForCall, struct{}{})
	fake.recordInvocation("CurrentBandwidthLimits", []interface{}{})
	fake.currentBandwidthLimitsMutex.Unlock()
	if fake.CurrentBandwidthLimitsStub != nil {
		return fake.CurrentBandwidthLimitsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.currentBandwidthLimitsReturns.result1, fake.currentBandwidthLimitsReturns.result2
}

func (fake *FakeContainer) CurrentBandwidthLimitsCallCount() int {
	fake.currentBandwidthLimitsMutex.RLock()
	defer fake.currentBandwidthLimitsMutex.RUnlock()
	return len(fake.currentBandwidthLimitsArgsForCall)
}

func (fake *FakeContainer) CurrentBandwidthLimitsReturns(result1 garden.BandwidthLimits, result2 error) {
	fake.CurrentBandwidthLimitsStub = nil
	fake.currentBandwidthLimitsReturns = struct {
		result1 garden.BandwidthLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentBandwidthLimitsReturnsOnCall(i int, result1 garden.BandwidthLimits, result2 error) {
	fake.CurrentBandwidthLimitsStub = nil
	if fake.currentBandwidthLimitsReturnsOnCall == nil {
		fake.currentBandwidthLimitsReturnsOnCall = make(map[int]struct {
			result1 garden.BandwidthLimits
			result2 error
		})
	}
	fake.currentBandwidthLimitsReturnsOnCall[i] = struct {
		result1 garden.BandwidthLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentCPULimits() (garden.CPULimits, error) {
	fake.currentCPULimitsMutex.Lock()
	ret, specificReturn := fake.currentCPULimitsReturnsOnCall[len(fake.currentCPULimitsArgsForCall)]
	fake.currentCPULimitsArgsForCall = append(fake.currentCPULimitsArgsForCall, struct{}{})
	fake.recordInvocation("CurrentCPULimits", []interface{}{})
	fake.currentCPULimitsMutex.Unlock()
	if fake.CurrentCPULimitsStub != nil {
		return fake.CurrentCPULimitsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.currentCPULimitsReturns.result1, fake.currentCPULimitsReturns.result2
}

func (fake *FakeContainer) CurrentCPULimitsCallCount() int {
	fake.currentCPULimitsMutex.RLock()
	defer fake.currentCPULimitsMutex.RUnlock()
	return len(fake.currentCPULimitsArgsForCall)
}

func (fake *FakeContainer) CurrentCPULimitsReturns(result1 garden.CPULimits, result2 error) {
	fake.CurrentCPULimitsStub = nil
	fake.currentCPULimitsReturns = struct {
		result1 garden.CPULimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentCPULimitsReturnsOnCall(i int, result1 garden.CPULimits, result2 error) {
	fake.CurrentCPULimitsStub = nil
	if fake.currentCPULimitsReturnsOnCall == nil {
		fake.currentCPULimitsReturnsOnCall = make(map[int]struct {
			result1 garden.CPULimits
			result2 error
		})
	}
	fake.currentCPULimitsReturnsOnCall[i] = struct {
		result1 garden.CPULimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentDiskLimits() (garden.DiskLimits, error) {
	fake.currentDiskLimitsMutex.Lock()
	ret, specificReturn := fake.currentDiskLimitsReturnsOnCall[len(fake.currentDiskLimitsArgsForCall)]
	fake.currentDiskLimitsArgsForCall = append(fake.currentDiskLimitsArgsForCall, struct{}{})
	fake.recordInvocation("CurrentDiskLimits", []interface{}{})
	fake.currentDiskLimitsMutex.Unlock()
	if fake.CurrentDiskLimitsStub != nil {
		return fake.CurrentDiskLimitsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.currentDiskLimitsReturns.result1, fake.currentDiskLimitsReturns.result2
}

func (fake *FakeContainer) CurrentDiskLimitsCallCount() int {
	fake.currentDiskLimitsMutex.RLock()
	defer fake.currentDiskLimitsMutex.RUnlock()
	return len(fake.currentDiskLimitsArgsForCall)
}

func (fake *FakeContainer) CurrentDiskLimitsReturns(result1 garden.DiskLimits, result2 error) {
	fake.CurrentDiskLimitsStub = nil
	fake.currentDiskLimitsReturns = struct {
		result1 garden.DiskLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentDiskLimitsReturnsOnCall(i int, result1 garden.DiskLimits, result2 error) {
	fake.CurrentDiskLimitsStub = nil
	if fake.currentDiskLimitsReturnsOnCall == nil {
		fake.currentDiskLimitsReturnsOnCall = make(map[int]struct {
			result1 garden.DiskLimits
			result2 error
		})
	}
	fake.currentDiskLimitsReturnsOnCall[i] = struct {
		result1 garden.DiskLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentMemoryLimits() (garden.MemoryLimits, error) {
	fake.currentMemoryLimitsMutex.Lock()
	ret, specificReturn := fake.currentMemoryLimitsReturnsOnCall[len(fake.currentMemoryLimitsArgsForCall)]
	fake.currentMemoryLimitsArgsForCall = append(fake.currentMemoryLimitsArgsForCall, struct{}{})
	fake.recordInvocation("CurrentMemoryLimits", []interface{}{})
	fake.currentMemoryLimitsMutex.Unlock()
	if fake.CurrentMemoryLimitsStub != nil {
		return fake.CurrentMemoryLimitsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.currentMemoryLimitsReturns.result1, fake.currentMemoryLimitsReturns.result2
}

func (fake *FakeContainer) CurrentMemoryLimitsCallCount() int {
	fake.currentMemoryLimitsMutex.RLock()
	defer fake.currentMemoryLimitsMutex.RUnlock()
	return len(fake.currentMemoryLimitsArgsForCall)
}

func (fake *FakeContainer) CurrentMemoryLimitsReturns(result1 garden.MemoryLimits, result2 error) {
	fake.CurrentMemoryLimitsStub = nil
	fake.currentMemoryLimitsReturns = struct {
		result1 garden.MemoryLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentMemoryLimitsReturnsOnCall(i int, result1 garden.MemoryLimits, result2 error) {
	fake.CurrentMemoryLimitsStub = nil
	if fake.currentMemoryLimitsReturnsOnCall == nil {
		fake.currentMemoryLimitsReturnsOnCall = make(map[int]struct {
			result1 garden.MemoryLimits
			result2 error
		})
	}
	fake.currentMemoryLimitsReturnsOnCall[i] = struct {
		result1 garden.MemoryLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) NetIn(hostPort uint32, containerPort uint32) (uint32, uint32, error) {
	fake.netInMutex.Lock()
	ret, specificReturn := fake.netInReturnsOnCall[len(fake.netInArgsForCall)]
	fake.netInArgsForCall = append(fake.netInArgsForCall, struct {
		hostPort      uint32
		containerPort uint32
	}{hostPort, containerPort})
	fake.recordInvocation("NetIn", []interface{}{hostPort, containerPort})
	fake.netInMutex.Unlock()
	if fake.NetInStub != nil {
		return fake.NetInStub(hostPort, containerPort)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.netInReturns.result1, fake.netInReturns.result2, fake.netInReturns.result3
}

func (fake *FakeContainer) NetInCallCount() int {
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	return len(fake.netInArgsForCall)
}

func (fake *FakeContainer) NetInArgsForCall(i int) (uint32, uint32) {
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	return fake.netInArgsForCall[i].hostPort, fake.netInArgsForCall[i].containerPort
}

func (fake *FakeContainer) NetInReturns(result1 uint32, result2 uint32, result3 error) {
	fake.NetInStub = nil
	fake.netInReturns = struct {
		result1 uint32
		result2 uint32
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeContainer) NetInReturnsOnCall(i int, result1 uint32, result2 uint32, result3 error) {
	fake.NetInStub = nil
	if fake.netInReturnsOnCall == nil {
		fake.netInReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 uint32
			result3 error
		})
	}
	fake.netInReturnsOnCall[i] = struct {
		result1 uint32
		result2 uint32
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeContainer) NetOut(netOutRule garden.NetOutRule) error {
	fake.netOutMutex.Lock()
	ret, specificReturn := fake.netOutReturnsOnCall[len(fake.netOutArgsForCall)]
	fake.netOutArgsForCall = append(fake.netOutArgsForCall, struct {
		netOutRule garden.NetOutRule
	}{netOutRule})
	fake.recordInvocation("NetOut", []interface{}{netOutRule})
	fake.netOutMutex.Unlock()
	if fake.NetOutStub != nil {
		return fake.NetOutStub(netOutRule)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.netOutReturns.result1
}

func (fake *FakeContainer) NetOutCallCount() int {
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	return len(fake.netOutArgsForCall)
}

func (fake *FakeContainer) NetOutArgsForCall(i int) garden.NetOutRule {
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	return fake.netOutArgsForCall[i].netOutRule
}

func (fake *FakeContainer) NetOutReturns(result1 error) {
	fake.NetOutStub = nil
	fake.netOutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) NetOutReturnsOnCall(i int, result1 error) {
	fake.NetOutStub = nil
	if fake.netOutReturnsOnCall == nil {
		fake.netOutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.netOutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) BulkNetOut(netOutRules []garden.NetOutRule) error {
	var netOutRulesCopy []garden.NetOutRule
	if netOutRules != nil {
		netOutRulesCopy = make([]garden.NetOutRule, len(netOutRules))
		copy(netOutRulesCopy, netOutRules)
	}
	fake.bulkNetOutMutex.Lock()
	ret, specificReturn := fake.bulkNetOutReturnsOnCall[len(fake.bulkNetOutArgsForCall)]
	fake.bulkNetOutArgsForCall = append(fake.bulkNetOutArgsForCall, struct {
		netOutRules []garden.NetOutRule
	}{netOutRulesCopy})
	fake.recordInvocation("BulkNetOut", []interface{}{netOutRulesCopy})
	fake.bulkNetOutMutex.Unlock()
	if fake.BulkNetOutStub != nil {
		return fake.BulkNetOutStub(netOutRules)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bulkNetOutReturns.result1
}

func (fake *FakeContainer) BulkNetOutCallCount() int {
	fake.bulkNetOutMutex.RLock()
	defer fake.bulkNetOutMutex.RUnlock()
	return len(fake.bulkNetOutArgsForCall)
}

func (fake *FakeContainer) BulkNetOutArgsForCall(i int) []garden.NetOutRule {
	fake.bulkNetOutMutex.RLock()
	defer fake.bulkNetOutMutex.RUnlock()
	return fake.bulkNetOutArgsForCall[i].netOutRules
}

func (fake *FakeContainer) BulkNetOutReturns(result1 error) {
	fake.BulkNetOutStub = nil
	fake.bulkNetOutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) BulkNetOutReturnsOnCall(i int, result1 error) {
	fake.BulkNetOutStub = nil
	if fake.bulkNetOutReturnsOnCall == nil {
		fake.bulkNetOutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bulkNetOutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Run(arg1 garden.ProcessSpec, arg2 garden.ProcessIO) (garden.Process, error) {
	fake.runMutex.Lock()
	ret, specificReturn := fake.runReturnsOnCall[len(fake.runArgsForCall)]
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		arg1 garden.ProcessSpec
		arg2 garden.ProcessIO
	}{arg1, arg2})
	fake.recordInvocation("Run", []interface{}{arg1, arg2})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		return fake.RunStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.runReturns.result1, fake.runReturns.result2
}

func (fake *FakeContainer) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeContainer) RunArgsForCall(i int) (garden.ProcessSpec, garden.ProcessIO) {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return fake.runArgsForCall[i].arg1, fake.runArgsForCall[i].arg2
}

func (fake *FakeContainer) RunReturns(result1 garden.Process, result2 error) {
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) RunReturnsOnCall(i int, result1 garden.Process, result2 error) {
	fake.RunStub = nil
	if fake.runReturnsOnCall == nil {
		fake.runReturnsOnCall = make(map[int]struct {
			result1 garden.Process
			result2 error
		})
	}
	fake.runReturnsOnCall[i] = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) Attach(processID string, io garden.ProcessIO) (garden.Process, error) {
	fake.attachMutex.Lock()
	ret, specificReturn := fake.attachReturnsOnCall[len(fake.attachArgsForCall)]
	fake.attachArgsForCall = append(fake.attachArgsForCall, struct {
		processID string
		io        garden.ProcessIO
	}{processID, io})
	fake.recordInvocation("Attach", []interface{}{processID, io})
	fake.attachMutex.Unlock()
	if fake.AttachStub != nil {
		return fake.AttachStub(processID, io)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.attachReturns.result1, fake.attachReturns.result2
}

func (fake *FakeContainer) AttachCallCount() int {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return len(fake.attachArgsForCall)
}

func (fake *FakeContainer) AttachArgsForCall(i int) (string, garden.ProcessIO) {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return fake.attachArgsForCall[i].processID, fake.attachArgsForCall[i].io
}

func (fake *FakeContainer) AttachReturns(result1 garden.Process, result2 error) {
	fake.AttachStub = nil
	fake.attachReturns = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) AttachReturnsOnCall(i int, result1 garden.Process, result2 error) {
	fake.AttachStub = nil
	if fake.attachReturnsOnCall == nil {
		fake.attachReturnsOnCall = make(map[int]struct {
			result1 garden.Process
			result2 error
		})
	}
	fake.attachReturnsOnCall[i] = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) Metrics() (garden.Metrics, error) {
	fake.metricsMutex.Lock()
	ret, specificReturn := fake.metricsReturnsOnCall[len(fake.metricsArgsForCall)]
	fake.metricsArgsForCall = append(fake.metricsArgsForCall, struct{}{})
	fake.recordInvocation("Metrics", []interface{}{})
	fake.metricsMutex.Unlock()
	if fake.MetricsStub != nil {
		return fake.MetricsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.metricsReturns.result1, fake.metricsReturns.result2
}

func (fake *FakeContainer) MetricsCallCount() int {
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	return len(fake.metricsArgsForCall)
}

func (fake *FakeContainer) MetricsReturns(result1 garden.Metrics, result2 error) {
	fake.MetricsStub = nil
	fake.metricsReturns = struct {
		result1 garden.Metrics
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) MetricsReturnsOnCall(i int, result1 garden.Metrics, result2 error) {
	fake.MetricsStub = nil
	if fake.metricsReturnsOnCall == nil {
		fake.metricsReturnsOnCall = make(map[int]struct {
			result1 garden.Metrics
			result2 error
		})
	}
	fake.metricsReturnsOnCall[i] = struct {
		result1 garden.Metrics
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) SetGraceTime(graceTime time.Duration) error {
	fake.setGraceTimeMutex.Lock()
	ret, specificReturn := fake.setGraceTimeReturnsOnCall[len(fake.setGraceTimeArgsForCall)]
	fake.setGraceTimeArgsForCall = append(fake.setGraceTimeArgsForCall, struct {
		graceTime time.Duration
	}{graceTime})
	fake.recordInvocation("SetGraceTime", []interface{}{graceTime})
	fake.setGraceTimeMutex.Unlock()
	if fake.SetGraceTimeStub != nil {
		return fake.SetGraceTimeStub(graceTime)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setGraceTimeReturns.result1
}

func (fake *FakeContainer) SetGraceTimeCallCount() int {
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	return len(fake.setGraceTimeArgsForCall)
}

func (fake *FakeContainer) SetGraceTimeArgsForCall(i int) time.Duration {
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	return fake.setGraceTimeArgsForCall[i].graceTime
}

func (fake *FakeContainer) SetGraceTimeReturns(result1 error) {
	fake.SetGraceTimeStub = nil
	fake.setGraceTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) SetGraceTimeReturnsOnCall(i int, result1 error) {
	fake.SetGraceTimeStub = nil
	if fake.setGraceTimeReturnsOnCall == nil {
		fake.setGraceTimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setGraceTimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Properties() (garden.Properties, error) {
	fake.propertiesMutex.Lock()
	ret, specificReturn := fake.propertiesReturnsOnCall[len(fake.propertiesArgsForCall)]
	fake.propertiesArgsForCall = append(fake.propertiesArgsForCall, struct{}{})
	fake.recordInvocation("Properties", []interface{}{})
	fake.propertiesMutex.Unlock()
	if fake.PropertiesStub != nil {
		return fake.PropertiesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.propertiesReturns.result1, fake.propertiesReturns.result2
}

func (fake *FakeContainer) PropertiesCallCount() int {
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	return len(fake.propertiesArgsForCall)
}

func (fake *FakeContainer) PropertiesReturns(result1 garden.Properties, result2 error) {
	fake.PropertiesStub = nil
	fake.propertiesReturns = struct {
		result1 garden.Properties
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) PropertiesReturnsOnCall(i int, result1 garden.Properties, result2 error) {
	fake.PropertiesStub = nil
	if fake.propertiesReturnsOnCall == nil {
		fake.propertiesReturnsOnCall = make(map[int]struct {
			result1 garden.Properties
			result2 error
		})
	}
	fake.propertiesReturnsOnCall[i] = struct {
		result1 garden.Properties
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) Property(name string) (string, error) {
	fake.propertyMutex.Lock()
	ret, specificReturn := fake.propertyReturnsOnCall[len(fake.propertyArgsForCall)]
	fake.propertyArgsForCall = append(fake.propertyArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Property", []interface{}{name})
	fake.propertyMutex.Unlock()
	if fake.PropertyStub != nil {
		return fake.PropertyStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.propertyReturns.result1, fake.propertyReturns.result2
}

func (fake *FakeContainer) PropertyCallCount() int {
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	return len(fake.propertyArgsForCall)
}

func (fake *FakeContainer) PropertyArgsForCall(i int) string {
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	return fake.propertyArgsForCall[i].name
}

func (fake *FakeContainer) PropertyReturns(result1 string, result2 error) {
	fake.PropertyStub = nil
	fake.propertyReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) PropertyReturnsOnCall(i int, result1 string, result2 error) {
	fake.PropertyStub = nil
	if fake.propertyReturnsOnCall == nil {
		fake.propertyReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.propertyReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) SetProperty(name string, value string) error {
	fake.setPropertyMutex.Lock()
	ret, specificReturn := fake.setPropertyReturnsOnCall[len(fake.setPropertyArgsForCall)]
	fake.setPropertyArgsForCall = append(fake.setPropertyArgsForCall, struct {
		name  string
		value string
	}{name, value})
	fake.recordInvocation("SetProperty", []interface{}{name, value})
	fake.setPropertyMutex.Unlock()
	if fake.SetPropertyStub != nil {
		return fake.SetPropertyStub(name, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setPropertyReturns.result1
}

func (fake *FakeContainer) SetPropertyCallCount() int {
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	return len(fake.setPropertyArgsForCall)
}

func (fake *FakeContainer) SetPropertyArgsForCall(i int) (string, string) {
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	return fake.setPropertyArgsForCall[i].name, fake.setPropertyArgsForCall[i].value
}

func (fake *FakeContainer) SetPropertyReturns(result1 error) {
	fake.SetPropertyStub = nil
	fake.setPropertyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) SetPropertyReturnsOnCall(i int, result1 error) {
	fake.SetPropertyStub = nil
	if fake.setPropertyReturnsOnCall == nil {
		fake.setPropertyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setPropertyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) RemoveProperty(name string) error {
	fake.removePropertyMutex.Lock()
	ret, specificReturn := fake.removePropertyReturnsOnCall[len(fake.removePropertyArgsForCall)]
	fake.removePropertyArgsForCall = append(fake.removePropertyArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("RemoveProperty", []interface{}{name})
	fake.removePropertyMutex.Unlock()
	if fake.RemovePropertyStub != nil {
		return fake.RemovePropertyStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removePropertyReturns.result1
}

func (fake *FakeContainer) RemovePropertyCallCount() int {
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	return len(fake.removePropertyArgsForCall)
}

func (fake *FakeContainer) RemovePropertyArgsForCall(i int) string {
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	return fake.removePropertyArgsForCall[i].name
}

func (fake *FakeContainer) RemovePropertyReturns(result1 error) {
	fake.RemovePropertyStub = nil
	fake.removePropertyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) RemovePropertyReturnsOnCall(i int, result1 error) {
	fake.RemovePropertyStub = nil
	if fake.removePropertyReturnsOnCall == nil {
		fake.removePropertyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removePropertyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.handleMutex.RLock()
	defer fake.handleMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	fake.currentBandwidthLimitsMutex.RLock()
	defer fake.currentBandwidthLimitsMutex.RUnlock()
	fake.currentCPULimitsMutex.RLock()
	defer fake.currentCPULimitsMutex.RUnlock()
	fake.currentDiskLimitsMutex.RLock()
	defer fake.currentDiskLimitsMutex.RUnlock()
	fake.currentMemoryLimitsMutex.RLock()
	defer fake.currentMemoryLimitsMutex.RUnlock()
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	fake.bulkNetOutMutex.RLock()
	defer fake.bulkNetOutMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeContainer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ garden.Container = new(FakeContainer)
